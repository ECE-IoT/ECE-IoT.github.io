{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ESP IoT Framework This frameworks intention is to simplify the development of ESP32 IoT Devices, which interact with AWS Services. The framework is complemented by the AWS IoT Framework Motivation Overview The networking of sensors and actuators via the internet is becoming increasingly important in industry, but also in the private sector. In this project work it will be shown how a processing chain from the sensor to the cloud service (AWS) can be realized practically. The project aims to provide a valuable overview of what is possible with embedded/connected IoT devices that can transmit data to the cloud. In addition, the projects goal was to provide a secure connection to AWS. Attention Please be aware that this project is a feasibility study. It does not provide code which is ready for production, or similar. Further information about the future intentions of this project can be found here. OpenSource This project can be accessed via the MIT License. Based upon this license the project team highly encourages people who are keen on getting in touch with embedded IoT applications to contribute to this project. Getting started in order to get started with developing or using the code head over to Setup","title":"Introduction"},{"location":"#esp-iot-framework","text":"This frameworks intention is to simplify the development of ESP32 IoT Devices, which interact with AWS Services. The framework is complemented by the AWS IoT Framework","title":"ESP IoT Framework"},{"location":"#motivation","text":"","title":"Motivation"},{"location":"#overview","text":"The networking of sensors and actuators via the internet is becoming increasingly important in industry, but also in the private sector. In this project work it will be shown how a processing chain from the sensor to the cloud service (AWS) can be realized practically. The project aims to provide a valuable overview of what is possible with embedded/connected IoT devices that can transmit data to the cloud. In addition, the projects goal was to provide a secure connection to AWS. Attention Please be aware that this project is a feasibility study. It does not provide code which is ready for production, or similar. Further information about the future intentions of this project can be found here.","title":"Overview"},{"location":"#opensource","text":"This project can be accessed via the MIT License. Based upon this license the project team highly encourages people who are keen on getting in touch with embedded IoT applications to contribute to this project.","title":"OpenSource"},{"location":"#getting-started","text":"in order to get started with developing or using the code head over to Setup","title":"Getting started"},{"location":"setup/documentation/","text":"Documentation The documentation is generated by MkDocs with the Material for MkDocs Theme. MkDocs is a static site generator wich uses Markdown as markup language. For a Markdown cheat sheet click here . Local build Use the following command to build a local instance: mkdocs serve The documentation can be accessed on the local address shown in the terminal ( http://localhost:8000 ) Hint mkdocs handles updates of your .md code automatically. You don't need to run the command twice when updates are made. Assuming you are still in the same session Deploy When the documentation is ready it can be uploaded to GitHub using: mkdocs gh-deploy This will automatically build an upload the site to GitHub using the branch gh-pages . Warning Please avoid modifying the branch gh-pages manually. Useful Commands Diagrams Diagrams can be created by using mermaid . Mermaid can be used by creating a code-block with the mermaid language tag. ```mermaid <your diagram> ```","title":"Documentation"},{"location":"setup/documentation/#documentation","text":"The documentation is generated by MkDocs with the Material for MkDocs Theme. MkDocs is a static site generator wich uses Markdown as markup language. For a Markdown cheat sheet click here .","title":"Documentation"},{"location":"setup/documentation/#local-build","text":"Use the following command to build a local instance: mkdocs serve The documentation can be accessed on the local address shown in the terminal ( http://localhost:8000 ) Hint mkdocs handles updates of your .md code automatically. You don't need to run the command twice when updates are made. Assuming you are still in the same session","title":"Local build"},{"location":"setup/documentation/#deploy","text":"When the documentation is ready it can be uploaded to GitHub using: mkdocs gh-deploy This will automatically build an upload the site to GitHub using the branch gh-pages . Warning Please avoid modifying the branch gh-pages manually.","title":"Deploy"},{"location":"setup/documentation/#useful-commands","text":"","title":"Useful Commands"},{"location":"setup/documentation/#diagrams","text":"Diagrams can be created by using mermaid . Mermaid can be used by creating a code-block with the mermaid language tag. ```mermaid <your diagram> ```","title":"Diagrams"},{"location":"setup/setup/","text":"Getting started First steps Requirements Make sure that python 3.8 or higher and pip3 are installed on your PC. Next ensure that you have installed a capable text editor like VS Code (any other editor should work fine as long a you can use the necessary plugins for this project). Note If your are using VS Code you can install some very helpful extensions . Those extension are optional but will simplify writing code. Check out the extensions tab further below. Dependencies The project requires some python packages which are essential f.e. for embedded development (PlatformIO) or for building docs (Mkdocs). You can install them by using pip3 . Make sure that you are in the projects root folder Linux / macOS Windows pip3 install -r requirements.txt python3 -m pip install -r requirements.txt After the installation you should be able to use mkdocs and pio , which are the CLI tools for the documentation and platformIO. Hint For more information about mkdocs head to Documentation Extensions This list contains some good extensions which make developing code way easier. As always, this is just a short summary of what's possible. If you want to dig deeper into Extensions and Tools for VS Code, visit their docs . PlatformIO C++ C++ Extension Pack C/C++ Themes Python Pylance Mkdocs","title":"Getting Started"},{"location":"setup/setup/#getting-started","text":"","title":"Getting started"},{"location":"setup/setup/#first-steps","text":"","title":"First steps"},{"location":"setup/setup/#requirements","text":"Make sure that python 3.8 or higher and pip3 are installed on your PC. Next ensure that you have installed a capable text editor like VS Code (any other editor should work fine as long a you can use the necessary plugins for this project). Note If your are using VS Code you can install some very helpful extensions . Those extension are optional but will simplify writing code. Check out the extensions tab further below.","title":"Requirements"},{"location":"setup/setup/#dependencies","text":"The project requires some python packages which are essential f.e. for embedded development (PlatformIO) or for building docs (Mkdocs). You can install them by using pip3 . Make sure that you are in the projects root folder Linux / macOS Windows pip3 install -r requirements.txt python3 -m pip install -r requirements.txt After the installation you should be able to use mkdocs and pio , which are the CLI tools for the documentation and platformIO. Hint For more information about mkdocs head to Documentation","title":"Dependencies"},{"location":"setup/setup/#extensions","text":"This list contains some good extensions which make developing code way easier. As always, this is just a short summary of what's possible. If you want to dig deeper into Extensions and Tools for VS Code, visit their docs . PlatformIO C++ C++ Extension Pack C/C++ Themes Python Pylance Mkdocs","title":"Extensions"},{"location":"setup/structure/","text":"Structure This repository combines the source code, the documentation and the editor setup at once. Therefore it is crucial to understand the directories structure. The following folders are most likely to be changed by future developers: /src Here all every line of C++ code is put. Within this directory there are sub-folders in order to keep a tidy structure. When adding a new folder for a new structural element, give this folder a meaningful name. /scripts This folders intention is to store essential scripts which facilitate coding. Therefore all types of scripts can be put here ( python , shell etc.). /docs The /docs folder (like the name implies) stores every line of markdown code. In the future the intention of this project is to integrate a automatic doc generation tool like Doxygen . Doxygen allows the developer to write doc-strings which can be compiled into readable markdown code.","title":"Structure"},{"location":"setup/structure/#structure","text":"This repository combines the source code, the documentation and the editor setup at once. Therefore it is crucial to understand the directories structure. The following folders are most likely to be changed by future developers:","title":"Structure"},{"location":"setup/structure/#src","text":"Here all every line of C++ code is put. Within this directory there are sub-folders in order to keep a tidy structure. When adding a new folder for a new structural element, give this folder a meaningful name.","title":"/src"},{"location":"setup/structure/#scripts","text":"This folders intention is to store essential scripts which facilitate coding. Therefore all types of scripts can be put here ( python , shell etc.).","title":"/scripts"},{"location":"setup/structure/#docs","text":"The /docs folder (like the name implies) stores every line of markdown code. In the future the intention of this project is to integrate a automatic doc generation tool like Doxygen . Doxygen allows the developer to write doc-strings which can be compiled into readable markdown code.","title":"/docs"},{"location":"setup/coding-style/cpp/","text":"C++ coding style Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Hint Here is a link for a more detailed dive into `c++ core guidelines' Style guide by the Barr Group: Style Guide Naming conventions Variables The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global/Local variables Global/Local variables should be defined in a snake_case style. Example: int global_variable ; Private variables Private variables should be defined the same way as global variables. The main difference for private variables is a defined prefix _ . Example: int _private_variable ; Constants & Preprocessor Values Constants are expression with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: const int PI_VALUE = 3.14159 ; Functions A function is a block of code which runs when it's called. Data in form of parameters can be passed into a function. Functions can be written as non-returning and returning type. Functions should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFunktion () { // do some stuff } Classes (Types, Template parameters) C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. In the example picture shown above, there is the class car defined, which has certain methods and attributes . This class can be used to create different objects which share the same set of properties with different values. A class should be defined with all upper case (PascalCase) notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ) { brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int _current_speed ; }; void GeneralCar::setSpeed ( int new_speed ) { _current_speed = new_speed ; } int main () { // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; } Braces In order to get a clear structure the following braces scheme should be taking into account when programming. Every left brace ( { ) should be appear by itself on the line below it the block it opens. The corresponding right brace ( } ) should be placed by itself in the same position th appropriate number of lines later in the file. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; } else { car . price = \"low\" ; } The indentation should always be made with a tab . For every hierarchy step one tab has to be added. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; if ( car . weight >= 1000 ) { car . type = \"Truck\" ; } } else { car . price = \"low\" ; } Comments If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. For commenting block // should be used. Warning Inline comments should be used with caution, because they can cause chaotic code. Example DON'T // divides up two double values double division ( double dividend , double divisor ) { // this is the result variable double div ; // the result is calculated here: div = dividend / divisor ; // here the result is given back return div ; }","title":"C++"},{"location":"setup/coding-style/cpp/#c-coding-style","text":"Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Hint Here is a link for a more detailed dive into `c++ core guidelines' Style guide by the Barr Group: Style Guide","title":"C++ coding style"},{"location":"setup/coding-style/cpp/#naming-conventions","text":"","title":"Naming conventions"},{"location":"setup/coding-style/cpp/#variables","text":"The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global/Local variables Global/Local variables should be defined in a snake_case style. Example: int global_variable ; Private variables Private variables should be defined the same way as global variables. The main difference for private variables is a defined prefix _ . Example: int _private_variable ;","title":"Variables"},{"location":"setup/coding-style/cpp/#constants-preprocessor-values","text":"Constants are expression with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: const int PI_VALUE = 3.14159 ;","title":"Constants &amp; Preprocessor Values"},{"location":"setup/coding-style/cpp/#functions","text":"A function is a block of code which runs when it's called. Data in form of parameters can be passed into a function. Functions can be written as non-returning and returning type. Functions should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFunktion () { // do some stuff }","title":"Functions"},{"location":"setup/coding-style/cpp/#classes-types-template-parameters","text":"C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. In the example picture shown above, there is the class car defined, which has certain methods and attributes . This class can be used to create different objects which share the same set of properties with different values. A class should be defined with all upper case (PascalCase) notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ) { brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int _current_speed ; }; void GeneralCar::setSpeed ( int new_speed ) { _current_speed = new_speed ; } int main () { // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; }","title":"Classes (Types, Template parameters)"},{"location":"setup/coding-style/cpp/#braces","text":"In order to get a clear structure the following braces scheme should be taking into account when programming. Every left brace ( { ) should be appear by itself on the line below it the block it opens. The corresponding right brace ( } ) should be placed by itself in the same position th appropriate number of lines later in the file. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; } else { car . price = \"low\" ; } The indentation should always be made with a tab . For every hierarchy step one tab has to be added. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; if ( car . weight >= 1000 ) { car . type = \"Truck\" ; } } else { car . price = \"low\" ; }","title":"Braces"},{"location":"setup/coding-style/cpp/#comments","text":"If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. For commenting block // should be used. Warning Inline comments should be used with caution, because they can cause chaotic code. Example DON'T // divides up two double values double division ( double dividend , double divisor ) { // this is the result variable double div ; // the result is calculated here: div = dividend / divisor ; // here the result is given back return div ; }","title":"Comments"},{"location":"setup/coding-style/git/","text":"Branching System Commit Style In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. f.e git commit -m \"ADD function XY()\" FIX Used for minor changes, bugfixes of an already existing part of the code. f.e git commit -m \"FIX functionality of XY\" REF Written short for: REFACTOR. Is used when there is a major change in multiple code-segments and the structure of the code is reworked. f.e git commit -m \"UPDATE setup of analog sensors\" Creating Pull Requests In order to keep the master branch clean and functioning the prototyping repository has a branch protection rule . When someone wants to merge code onto the master branche a pull request has to be made. The pull request informs the admin of the repository to have a look over the code in order to approve if this its functioning and good code which can be merged without hesitation. In order to understand how to create a pull request have a look here source: https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f \u21a9","title":"Git"},{"location":"setup/coding-style/git/#branching-system","text":"","title":"Branching System"},{"location":"setup/coding-style/git/#commit-style","text":"In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. f.e git commit -m \"ADD function XY()\" FIX Used for minor changes, bugfixes of an already existing part of the code. f.e git commit -m \"FIX functionality of XY\" REF Written short for: REFACTOR. Is used when there is a major change in multiple code-segments and the structure of the code is reworked. f.e git commit -m \"UPDATE setup of analog sensors\"","title":"Commit Style"},{"location":"setup/coding-style/git/#creating-pull-requests","text":"In order to keep the master branch clean and functioning the prototyping repository has a branch protection rule . When someone wants to merge code onto the master branche a pull request has to be made. The pull request informs the admin of the repository to have a look over the code in order to approve if this its functioning and good code which can be merged without hesitation. In order to understand how to create a pull request have a look here source: https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f \u21a9","title":"Creating Pull Requests"},{"location":"software-planning/connection-handler/","text":"Class - ConnectionHandler The purpose of this class is to ensure that every remote connection is alive and maintained (Wifi, MQTT to broker). Features The main structure contains a state machine which handles the connection to the Wifi, sets up a TLS client for MQTT, enables a connection to the AWS MQTT Broker. Structure Basic UML in order to understand the structure of the class classDiagram class ConnectionHandler{ +ESPWifi esp_wifi +ESPLogger esp_logger +EspConfig *esp_config +MQTTClient *mqtt_client +enum states -ConnectionHandler() -state connectionStateMachine() }","title":"Class - ConnectionHandler"},{"location":"software-planning/connection-handler/#class-connectionhandler","text":"The purpose of this class is to ensure that every remote connection is alive and maintained (Wifi, MQTT to broker).","title":"Class - ConnectionHandler"},{"location":"software-planning/connection-handler/#features","text":"The main structure contains a state machine which handles the connection to the Wifi, sets up a TLS client for MQTT, enables a connection to the AWS MQTT Broker.","title":"Features"},{"location":"software-planning/connection-handler/#structure","text":"Basic UML in order to understand the structure of the class classDiagram class ConnectionHandler{ +ESPWifi esp_wifi +ESPLogger esp_logger +EspConfig *esp_config +MQTTClient *mqtt_client +enum states -ConnectionHandler() -state connectionStateMachine() }","title":"Structure"},{"location":"software-planning/sensors/","text":"Structure for implementing Sensor Modules A sensor module is a a type of measuring device which can be attached to the ESP32 via a serial connection (I2C, 1WIRE). The sensors of the module measures physical quantities like temperature or humidity, etc. In order to get a general form for adding new sensor modules to the framework the following points should be taken into account: A newly written class for a sensor module should always implement the EspComponent superclass. That is necessary to ensure a general structure when calling the new sensor modules object. The measured physical values which can be read of the sensor should be fed into a new instance of the sensor class. Structure Basic UML in order to understand the structure. The implemented sensor module DHT22 is just an example. classDiagram class EspComponent{ -void setup() -void setup(T setup_config) -void update() -void setValue() } class Sensor { +float sensor_value -char* sensor_type -char* unit -char* mqtt_topic -Sensor(char* sensor_type, char* mqtt_topic) -void setValue(float sensor_value) -void updateValue() } class DHT22 { -Sensor temperature -Sensor humidity -void setup() -void setValue() -void update() } EspComponent < |-- DHT22 Sensor --> DHT22 : contains","title":"Structure for implementing Sensor Modules"},{"location":"software-planning/sensors/#structure-for-implementing-sensor-modules","text":"A sensor module is a a type of measuring device which can be attached to the ESP32 via a serial connection (I2C, 1WIRE). The sensors of the module measures physical quantities like temperature or humidity, etc. In order to get a general form for adding new sensor modules to the framework the following points should be taken into account: A newly written class for a sensor module should always implement the EspComponent superclass. That is necessary to ensure a general structure when calling the new sensor modules object. The measured physical values which can be read of the sensor should be fed into a new instance of the sensor class.","title":"Structure for implementing Sensor Modules"},{"location":"software-planning/sensors/#structure","text":"Basic UML in order to understand the structure. The implemented sensor module DHT22 is just an example. classDiagram class EspComponent{ -void setup() -void setup(T setup_config) -void update() -void setValue() } class Sensor { +float sensor_value -char* sensor_type -char* unit -char* mqtt_topic -Sensor(char* sensor_type, char* mqtt_topic) -void setValue(float sensor_value) -void updateValue() } class DHT22 { -Sensor temperature -Sensor humidity -void setup() -void setValue() -void update() } EspComponent < |-- DHT22 Sensor --> DHT22 : contains","title":"Structure"}]}